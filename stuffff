library IEEE;
use ieee.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity main_module is
Port (clk               : in std_logic;
      data_in           : in std_logic;
      data_out          : out std_logic;
      enable_module     : in std_logic
    );
end main_module;

architecture Behavioral of main_module is

type ram is array (0 to 1027) of std_logic_vector(63 downto 0);

signal input_ram : ram :=(others => (others => '0'));
signal output_ram : ram := (others => (others => '0'));

signal m             : integer := 0;
signal n             : integer := 0;
signal p             : integer := 0;

type states is (idle, receive_elements, multiply_matrices, transmit_results,wait_for_transmission, wait_for_fp);
signal current_state : states := idle;

signal uart_receiver_output                          : std_logic_vector(7 downto 0):=(others => '0');
signal uart_receiver_output_valid                    : std_logic:='0';

signal uart_transmitter_data_to_send                 : std_logic_vector(7 downto 0):=(others => '0');
signal uart_transmitter_enable_transmit              : std_logic:='0';
signal uart_transmitter_tranmission_completed        : std_logic:='0';
    
component uart_receiver
    port (
        clk				     : in std_logic;
        input			     : in std_logic;
        output			     : out std_logic_vector (7 downto 0);
        output_valid         : out std_logic
);
end component;

COMPONENT floating_point_0
  PORT (
    aclk : IN STD_LOGIC;
    s_axis_a_tvalid : IN STD_LOGIC;
    s_axis_a_tdata : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
    s_axis_b_tvalid : IN STD_LOGIC;
    s_axis_b_tdata : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
    s_axis_c_tvalid : IN STD_LOGIC;
    s_axis_c_tdata : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
    m_axis_result_tvalid : OUT STD_LOGIC;
    m_axis_result_tdata : OUT STD_LOGIC_VECTOR(63 DOWNTO 0)
  );
END COMPONENT;

component uart_transmitter
    port (
        clk				        : in std_logic;
        data_to_send		    : in std_logic_vector (7 downto 0);
        enable_transmit		    : in std_logic;
        bit_out			        : out std_logic;
        transmission_completed	: out std_logic
);
end component;

signal ctr                      : integer := 0;
signal ctr2                     : integer := 0;
signal ram_adress               : integer := 0;
signal num1                     : std_logic_vector(63 downto 0):=(others => '0');
signal num2                     : std_logic_vector(63 downto 0) :=(others => '0');
signal total                    : std_logic_vector(63 downto 0) :=(others => '0');
signal zeros                    : std_logic_vector(63 downto 0) :=(others => '0');
signal matrix_A_current_row     : integer := 1;
signal matrix_A_current_col     : integer := 1;
signal matrix_B_current_row     : integer := 1;
signal matrix_B_current_col     : integer := 1;
signal fp_inputs_valid          : std_logic := '0';
signal fp_output_valid          : std_logic := '0';
begin

floating_point : floating_point_0
  PORT MAP (
    aclk => clk,
    s_axis_a_tvalid => fp_inputs_valid,
    s_axis_a_tdata => num1,
    s_axis_b_tvalid => fp_inputs_valid,
    s_axis_b_tdata => num2,
    s_axis_c_tvalid => fp_inputs_valid,
    s_axis_c_tdata => total,
    m_axis_result_tvalid => fp_output_valid ,
    m_axis_result_tdata => total
  );

uart_rx              : uart_receiver port map(clk =>clk, input => data_in, output => uart_receiver_output, output_valid => uart_receiver_output_valid);

uart_tx              : uart_transmitter port map(clk=>clk,data_to_send => uart_transmitter_data_to_send,enable_transmit =>uart_transmitter_enable_transmit, bit_out => data_out, transmission_completed =>uart_transmitter_tranmission_completed);

process(clk)
begin
    if enable_module = '1' then
        if rising_edge(clk) then
            case current_state is
                when idle =>
                    if data_in = '0' then
                        current_state <= receive_elements;
                    end if;
                when receive_elements =>
                    if uart_receiver_output_valid ='1' then
                         if ctr = 0 then
                            m <= to_integer(unsigned(uart_receiver_output));
                            ctr <= ctr + 1;
                         elsif ctr = 1 then
                            n <= to_integer(unsigned(uart_receiver_output));
                            ctr <= ctr + 1;
                         elsif ctr = 2 then
                            p <= to_integer(unsigned(uart_receiver_output));
                            ctr <= ctr + 1; 
                        elsif (ctr > 2) and ctr < (n*(m+p) + 2)  then
                            if ctr2 = 7 then
                                input_ram(ram_adress)(((ctr2+1)*8-1) downto (ctr2)*8) <= uart_receiver_output;  
                                ctr2 <= 0;
                                ram_adress <= ram_adress + 1;
                                ctr <= ctr + 1;          
                            else
                                input_ram(ram_adress)(((ctr2+1)*8-1) downto (ctr2)*8) <= uart_receiver_output;
                                ctr2 <= ctr2 + 1;
                            end if;         
                        elsif ctr  = (n*(m+p) + 2) then
                            if ctr2 = 7 then
                                input_ram(ram_adress)(((ctr2+1)*8-1) downto (ctr2)*8) <= uart_receiver_output;  
                                ram_adress <= 0;
                                current_state <= multiply_matrices;
                                ctr <= 0;         
                            else
                                input_ram(ram_adress)(((ctr2+1)*8-1) downto (ctr2)*8) <= uart_receiver_output;
                                ctr2 <= ctr2 + 1;
                            end if;                   
                    end if;
                end if;
                
                when wait_for_fp =>
                    fp_inputs_valid<= '0';
                    if fp_output_valid = '1' then
                        current_state <= multiply_matrices;
                    end if;
                when multiply_matrices =>
                    if matrix_A_current_row <= m then
                        if matrix_B_current_col <= p then
                            if ctr < n then --dikkat et
                                num1 <= input_ram((matrix_A_current_row-1)*m + matrix_A_current_col-1); 
                                num2 <= input_ram((matrix_B_current_row-1)*m + matrix_B_current_col-1 + m*n);
                                fp_inputs_valid<= '1';
                                current_state <= wait_for_fp;
                                matrix_A_current_col <=matrix_A_current_col + 1;   
                                matrix_B_current_row <=matrix_B_current_row + 1; 
                                ctr <= ctr + 1;  
                            else
                                ctr <= 0;
                                total <= zeros; 
                                num1 <= zeros;
                                num2 <= zeros;
                                output_ram(ram_adress) <= to_std_logic_vector(total);
                                ram_adress <= ram_adress + 1;
                                matrix_B_current_col <= matrix_B_current_col + 1;
                                matrix_A_current_col <= 1;
                                matrix_B_current_row <= 1;
                            end if;        
                        else
                            matrix_B_current_col <= 1;
                            matrix_A_current_row <= matrix_A_current_row + 1;
                        end if;
                    else
                        current_state <= transmit_results;
                        ctr <= 0;
                        ctr2 <= 0;
                        ram_adress <= 0;
                    end if; 
                    
                when wait_for_transmission =>
                    uart_transmitter_enable_transmit <= '0';
                    if uart_transmitter_tranmission_completed = '1' then
                        current_state <=transmit_results;
                    end if; 
                 
                when transmit_results =>  
                    if ctr < m*p then
                        if ctr2 = 7 then
                            ctr <= ctr + 1;
                            ctr2 <= 0;
                            ram_adress <= ram_adress + 1;
                            uart_transmitter_data_to_send <= output_ram(ram_adress)(63 downto 56);
                            uart_transmitter_enable_transmit <= '1';
                            current_state <= wait_for_transmission;
                        else
                            uart_transmitter_data_to_send <= output_ram(ram_adress)(((ctr2+1)*8-1) downto (ctr2)*8);
                            ctr2 <= ctr2 + 1;
                            uart_transmitter_enable_transmit <= '1';
                            current_state <= wait_for_transmission;
                        end if;
                    else
                        current_state <= idle;
                        input_ram <= (others => (others => '0'));
                        output_ram <= (others => (others => '0'));
                        ram_adress <= 0;
                        ctr <= 0;
                        ctr2 <= 0;
                    end if;              
            end case;
                    
        end if;
    end if;
end process;


end Behavioral;
